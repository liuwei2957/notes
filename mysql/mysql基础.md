### mysql基本架构

1. Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等
2. 存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎，存储引擎api包含几十个底层函数，用于执行诸如，开始一个事务，根据主键提取一行记录等操作，存储引擎不会去解析sql(Innodb会解析外键定义，因为mysql服务器本身没有实现该功能)

### sql执行流程

#### 查询

##### 连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限，建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接，但是全部使用长连接后，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉

###### 解决办法

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连
2. 如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态

##### 查询缓存

之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果，建议不要使用查询缓存，因为查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低MySQL 8.0版本直接将查询缓存的整块功能删掉了

##### 分析器

分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么，做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断输入的这个SQL语句是否满足MySQL语法

##### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序

##### 执行器

执行之前，要先判断一下有没有这个表的查询权限，如果有权限，就打开表继续执行。打开表的时候，执行器会根据表的引擎定义，去使用这个引擎提供的接口，数据库的慢查询日志中有一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的，在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的

###### 执行流程

1. 第一次调用的是“取满足条件的第一行”这个接口，将这行存在结果集中
2. 循环取“满足条件的下一行”这个接口，重复相同的判断逻辑，直到取到这个表的最后一行
3. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端

#### 更新

1. 连接
2. 清空查询缓存
3. 分析器会通过词法和语法解析知道这是一条更新语句
4. 优化器决定要使用哪个索引
5. 执行器负责具体执行，找到这一行，然后更新

#### 删除

1. 删除一行记录，InnoDB引擎只会把这个记录标记为删除。如果之后要再插入一个ID在这之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小
2. 如果我们删掉了一个数据页上的所有记录，整个数据页就可以被复用了，如果相邻的两个数据页利用率都很小，系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用
3. delete命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的
4. 不止是删除数据会造成空洞，插入数据也会

#### 删除空洞

1. alter table A engine=InnoDB重建表
