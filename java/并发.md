### 同步器

####  **闭锁**

1.  一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。即一组线程等待某一事件发生，事件没有发生前，所有线程将阻塞等待；而事件发生后，所有线程将开始执行；闭锁最初处于封闭状态，当事件发生后闭锁将被打开，一旦打开，闭锁将永远处于打开状态
2.  闭锁`CountDownLatch`唯一的构造方法**`CountDownLatch(int count)`**，当在闭锁上调用`countDown()`方法时，闭锁的计数器将减1，当闭锁计数器为0时，闭锁将打开，所有线程将通过闭锁开始执行 

####  **栅栏**

1.  一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点。利用栅栏，可以使线程相互等待，直到所有线程都到达某一点，然后栅栏将打开，所有线程将通过栅栏继续执行。`CyclicBarrier`支持一个可选的 `Runnable` 参数，当线程通过栅栏时，runnable对象将被调用。构造函数`CyclicBarrier(int **parties**, Runnable **barrierAction**)`，当线程在`CyclicBarrier`对象上调用`await()`方法时，栅栏的计数器将增加1，当计数器为`parties`时，栅栏将打开 

   区别：闭锁用于所有线程等待一个外部事件的发生；栅栏则是所有线程相互等待，直到所有线程都到达某一点时才打开栅栏，然后线程可以继续执行

#### 信号量

1. 计数信号量（Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量，计数信号量还可以用来实现某种资源池，或者对容器施加边界
2. Semaphore中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可（只要还有剩余许可），并在使用以后释放许可，如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者超时），release方法将返回一个许可给信号量

### 线程安全

1. 所有的并发问题都可以归纳为如何协调对并发状态的访问
2. 不可变对象一定是线程安全的，可以任意共享而无须使用加锁或保护性复制等机制
3. 当保护同一个不变性条件中的所有变量时，要使用同一个锁
4. 在执行复合操作期间，要持有锁（先检查再执行）
5. 将同步策略文档化

### 线程取消

1. 响应中断
2. 通过future.cancel()来实现取消

