###  **类加载层级关系**

1.  启动类加载器 （**BootClassLoader**） ： java虚拟机启动后创建的第一个类加载器，由C++语言实现， 负责在JVM启动时加载jdk自身的一些核心class类（jar包形式）到JVM中 ，所以我们在java代码中查看其信息时，看到的均为null 
2.   扩展类加载器 (**ExtClassLoader**) ：由启动类加载器加载，并将扩展类加载器中的parent的值设置为null（表示指向启动类加载器），同时继承自URLClassLoader 
3.  系统类加载器 （**AppClassLoader**） ：由启动类加载器加载，并将系统类加载期中的parent的值设置为上述创建的扩展类加载器，同时继承自URLClassLoader 

### 加载路径

![](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzXABTz0Z2gKXNoc7s7y5icqpt7VgJibPcjibtS3jiclJnqfVqht8Xm8QppQXszyu40ke6Zdk5G7RJYxg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###  **双亲委托机制** 

1. 当前类加载器(以系统类加载器为例)在加载一个类时，委托给其双亲（**注意这里的双亲指的是类加载器中parent属性指向的类加载器**）先进行加载 

2.  双亲类加载器在加载时同样委托给自己的双亲，如此反复，直到某个类加载器没有双亲为止，然后开始在依次在各自的类路径下寻找、加载class类 

   ![](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzXABTz0Z2gKXNoc7s7y5icqpJEicfeV6e4DM95qwl3gVlZvZiasTtrhUVBotXeDKbF2fcZiblQ7qfia6w/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 双亲委派模型有啥作用

 保证java基础类在不同的环境还是同一个Class对象，避免出现了自定义类覆盖基础类的情况，导致出现安全问题。还可以避免类的重复加载 

#### 如何打破双亲委派模型

1.  自定义类加载器，继承ClassLoader类重写loadClass方法 
2.  SPI 

##### SPI（Service Provider interface）

1.  服务提供接口（服务发现机制） 
2.  通过加载ClassPath下META_INF/services，自动加载文件里所定义的类 
3.  通过ServiceLoader.load/Service.providers方法通过反射拿到实现类的实例 

###### 应用

1.  应用于JDBC获取数据库驱动连接过程就是应用这一机制 
2.  apache最早提供的common-logging只有接口.没有实现..发现日志的提供商通过SPI来具体找到日志提供商实现类 

### 数据类型

1.  jvm包括两种数据类型，基本类型和引用类型 
2.  **基本类型**包括，数值类型，boolean类型，和returnAddress类型 
3.  数值类型包括，整型，浮点型，和char类型 
4.  boolean类型同样只有true和false 
5.  returnAddress类型是一个指针，指向jvm指令的操作码，在Java中没有与之对应的类型 
6.  boolean类型的操作会被转化为int类型的操作进行，boolean数组会当成byte数组去操作。1表示true，0表示false 
7.  **引用类型**包括三种，类类型，数组类型，和接口类型 ， 它们的值是动态创建的类实例，数组，或实现接口的类实例 
8.  数组有component类型和element类型，component类型就是数组去掉最外层维度后剩下的类型，可能还是一个数组类型（对于多维数组） 
9.  element类型就是数组里面存储的最小数据的类型，它必须是一个基本类型，类类型，或接口类型 
10.  对于一维数组的话，component类型和element类型是相同的 
11.  引用类型还有一个特殊值，就是null，表示没有引用任何对象 

###  **运行时数据区** 

#### 公有

#####  **堆** 

1. jvm有一个堆，在所有jvm线程间共享，堆是一个运行时数据区域，所有为类实例和数组分配的内存都来自于它 
2.  堆在jvm启动时创建，堆中对象不用显式释放，gc会帮我们释放并回收内存 

#####  **方法区**

1.  jvm有一个方法区，在所有jvm线程间共享，它存储每一个类的结构 ，像运行时常量池，字段和方法数据，方法和构造函数的代码，还有特殊的方法用于类和实例的初始化，以及接口的初始化
2.  方法区在jvm启动时创建，虽然方法区在逻辑上是堆的一部分  ， 但简单实现时可以选择不进行gc和压缩，本规范没有强制要求方法区的位置，也没有要求管理已编译代码的策略 

######  **运行时常量池**

1.  运行时常量池就是类或接口的字节码文件里的常量池的运行时表示形式，它包含几种常量 ， 如在编译时就已经知道的数字字面量值，和必须在运行时解析的方法和字段的引用，运行时常量池的功能类似于传统语言的符号表，不过它包含的数据会更加宽泛 
2.  运行时常量池分配在jvm的方法区，类或接口的运行时常量池在类或接口被jvm创建时才会构建 

#### 私有

#####  **pc寄存器**

1.  jvm支持一次运行多个线程，每个线程都有自己的pc寄存器，任何时候一个线程只能运行一个方法的代码 
2.  如果方法不是native的，pc寄存器包含当前正在被执行的jvm指令地址，如果方法是native的，pc寄存器的值是未定义的 

#####  **jvm栈**

1.  每一个jvm线程都有一个私有的jvm栈，随着线程的创建而创建，栈中存储的是帧 
2.  jvm栈和传统语言如C的栈相似，保存局部变量和部分计算结果，参与方法的调用和返回。jvm栈主要用于帧的出栈和入栈，除此之外没有其它操作 
3.  帧可能是在堆上分配的，所以jvm栈使用的内存不必是连续的 

######  **帧**

1.  每次当一个方法被调用时一个新的帧会被创建。当方法调用完成时，与之对应的帧会被销毁，无论是正常完成还是抛异常结束 
2.  帧是方法调用的具体体现形式，或称方法调用是以帧的形式进行的。帧用来存储数据和部分计算结果，和执行动态链接，方法返回值，分发异常 
3.  帧分配在创建帧的线程的jvm栈上，每一个帧都有自己的本地变量数组，自己的操作数据栈，和一个对当前方法所在类的运行时常量池的引用 
4.  本地变量数组和操作数栈的大小在编译时就确定了，它们随着和帧关联的方法编译后的代码一起被提供，因此帧这种数据结构的大小只依赖于jvm的实现，这些结构所需的内存可以在方法调用时同时被分配 
5.  在一个线程执行的任何时刻，都只会有一个帧是处于激活的。这个帧被称为当前帧，与之对应的方法被称为当前方法，方法所在的类被称为当前类，此时用到的本地变量数组和操作数栈也都是当前帧的 ， 当方法返回时，当前帧把方法执行的结果传回到上一帧，当上一帧被激活的同时当前帧会被丢弃 

######  **本地变量数组**

1.  每一帧都包含一个变量数组，就是都熟知的本地变量存储的地方。这个本地变量数组的长度在编译时确定，随着编译后的方法代码一起提供 
2.  通常一个本地变量（的位置）能够存储一个类型的值，但是long和double类型却需要两个本地变量（的位置）才能存一个值 
3.  在实例（非静态）方法调用时，索引0处总是传入正在其上执行方法调用的那个对象的引用，（就是Java中的this了），所有参数被传入从1开始的连贯的本地变量数组里 

######  **操作数栈**

1.  每个帧包含一个后进先出的栈，用于存储正在执行的jvm指令的操作数，就是都熟知的操作数栈，这个栈的最大深度在编译时就已确定，随着编译后的方法代码一起提供 
2.  当帧被创建时，操作数栈是空的，jvm提供一些指令用于加载常量值，本地变量值，字段值到操作数栈上，另一些jvm指令采用操作数栈上的操作数进行操作，并把结果放回到操作数栈上 
3.  操作数栈也用于准备将要传递给方法调用的参数和接收方法调用返回的结果 

######  **动态链接**

1.  每一个帧都包含了对当前方法所属类型的运行时常量池的引用。目的是为了支持方法代码的动态链接 ， class文件中描述一个方法引用被调用的方法和被访问的变量的代码，是采用符号引用的形式实现的 
2.  符号引用的形式可以粗略的认为是字符串的形式，就是用字符串标明需要调用哪个类的哪个方法或访问哪个字段或变量。就像符号引用这个名字一样，这些仅仅是符号，是拿不到具体值的，所以必须要进行转换 
3.  动态链接就是把这些符号方法引用转换为具体的方法引用，在必要时加载类来解析尚未明确的符号，把符号变量的访问转换为这些变量运行时所在存储结构的适合的偏移量（索引）。这样的方式又称为后期绑定 

######  **方法调用**

1.  一个方法调用正常完成（即没有抛异常）时，会根据所返回的值的类型执行一个适合的return指令，当前帧会去恢复调用者的状态，包括它的本地变量和操作数栈，使调用者的程序计数器适合的递增来跳过刚刚的那个方法调用指令 
2.  返回值会被放到调用者帧的操作数栈上，然后继续执行调用者方法的帧 
3.  一个方法在调用时抛出了异常，且这个异常没有在这个方法内被捕获处理，将会导致这个方法调用的突然结束，这种情况下永远不会向方法的调用者返回一个值 

######  **特殊方法**

1.  站在jvm的级别，每一个用Java写的构造函数都以一个实例初始化方法出现，且都是特殊的名字，就是<init>，这个名字是编译器提供的 
2.  实例初始化方法只能在jvm内部使用*invokespecial*这个指令调用，且只能在尚未初始化的类实例上调用 
3.  一个类或接口最多可以有一个类或接口初始化方法，通过调用这个方法被初始化。类或接口的初始化方法也有特殊的名字，就是<clinit>，该方法没有参数，且返回值是void 
4.  这个初始化方法是被jvm隐式调用的，它们绝对不会直接被用任何jvm指令调用，仅作为类初始化进程的一部分被间接的调用 

#####  **native方法栈**

 native方法不是用Java语言写的，为了支持它需要使用传统栈，如C语言栈。不过jvm不能加载native方法，所以也不需要提供native方法需要的栈 

### 内存分配

每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存 ， 这种方案被称之为TLAB分配，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的 

#### **TLAB**

1. TLAB是虚拟机在堆内存的eden划分出来的一块专用空间，是线程专属的。在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率 
2.  我们说TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别 
3.  eden区域本身就不太大，而且TLAB空间的内存也非常小，默认情况下仅占有整个Eden空间的1%。所以，必然存在一些大对象是无法在TLAB直接分配 
4.  遇到TLAB中无法分配的大对象，对象还是可能在eden区或者老年代等进行分配的，但是这种分配就需要进行同步控制 

##### **问题**

 因为TLAB内存区域并不是很大，所以，有可能会经常出现不够的情况 ， 有两种处理方案 

1.  如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则直接在堆内存中对该对象进行内存分配 

2.  如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则废弃当前TLAB，重新申请TLAB空间再次进行内存分配 

3.  以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是TLAB只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配 ， 如果采用方案2，也有可能存在频繁废弃TLAB，频繁申请TLAB的情况，而我们知道，虽然在TLAB上分配内存是线程独享的，但是TLAB内存自己从堆中划分出来的过程确实可能存在冲突的，所以，TLAB的分配过程其实也是需要并发控制的。而频繁的TLAB分配就失去了使用TLAB的意义 

4.  为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间” ， 当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配 

5.  TLAB的空间其实并不大，所以大对象还是可能需要在堆内存中直接分配。那么，对象的内存分配步骤就是先尝试TLAB分配，空间不足之后，再判断是否应该直接进入老年代，然后再确定是再eden分配还是在老年代分配 

   ![](https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5J3QXqDic5IRhC21FgJQ5IrSeicqsxPAc3mIAnbxYngicBicWmngenzELUCDs2wOSX4iasMTqaV499csUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### jvm内存

####  年轻代

 年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC 

1.  大多数新建的对象都位于Eden区 
2.  当Eden区被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个survivor区 
3.  Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区 
4.  经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间，通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的 

#### 年老代

 年老代内存里包含了长期存活的对象和经过多次Minor GC后依然存活下来的对象，通常会在老年代内存被占满时进行垃圾回收 

### gc

#### Major GC

 老年代的垃圾收集叫做Major GC，Major GC通常是跟full GC是等价的，收集整个GC堆 

#### 分代GC

1. Young GC：只收集年轻代的GC
2. Old GC：只收集年老代的GC(只有CMS的concurrent collection是这个模式)
3. Mixed GC：收集整个young gen以及部分old gen的GC(只有G1有这个模式)

#### Full GC

 Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC 

### 堆内内存

1. 减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作。加快了复制的速度。因为堆内在 flush 到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了复制这项工作。可以扩展至更大的内存空间。比如超过 1TB 甚至比主存还大的空间 
2.  堆外内存难以控制，如果内存泄漏，那么很难排查，通过-XX：MaxDirectMemerySize来指定，当达到阈值的时候，调用system.gc来进行一次full gc 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合 jstat查看内存回收概况，实时查看各个分区的分配回收情况， jmap查看内存栈，查看内存中对象占用大小， jstack查看线程栈，死锁，性能瓶颈 

### JVM七种垃圾收集器

-  Serial 收集器 复制算法，单线程，新生代） 
-  ParNew 收集器（复制算法，多线程，新生代） 
-  Parallel Scavenge 收集器（多线程，复制算法，新生代，高吞吐量） 
-  Serial Old 收集器（标记-整理算法，老年代） 
-  Parallel Old 收集器（标记-整理算法，老年代，注重吞吐量的场景下，jdk8默认采用 Parallel Scavenge + Parallel Old 的组合） 
-  CMS 收集器（标记-清除算法，老年代，垃圾回收线程几乎能做到与用户线程同时工作，吞吐量低，内存碎片）以牺牲吞吐量为代价来获得最短回收停顿时间-XX：+UseConcMarkSweepGC jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代） jdk1.9 默认垃圾收集器G1 

#### cms使用场景

1.  应用程序对停顿比较敏感 
2.  在JVM中，有相对较多存活时间较长的对象（老年代比较大）会更适合使用CMS 

#### 回收过程

1.  初始标识<找到gcroot（stw）> 
2.  并发标记（三色标记算法） 三色标记算法处理并发标记出现对象引用变化情况 
3.  重新标记（stw） （ 重新标记是防止标记成垃圾之后，对象被引用 ）
4.  并发清理 

