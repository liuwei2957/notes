### 零拷贝

#### 直接io

1.  CPU 发出对应的指令给磁盘控制器，然后返回 

2.  磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个**中断** 

3.  CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的 

   ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHKiczImueTBjnrXSnRM13meibUYyVDUQKQNrp8qAERdb7v0SvHcDGMI6RoSE4y8ibpGqF1agxyDiaiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

####  **直接内存访问**

 **在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务**

1.  用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态 
2.  操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务 
3.  DMA 进一步将 I/O 请求发送给磁盘 
4.  磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满 
5.  **DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务** 
6.  当 DMA 读取了足够多的数据，就会发送中断信号给 CPU 
7.  CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回 

![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHKiczImueTBjnrXSnRM13mF08dz9WOND7zqicNq8bs0mOmu2jSaJiaFEJru35teqvibMCxPCLsyp2mg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 

#### 传统文件传输

首先，期间共**发生了 4 次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是 `read()` ，一次是 `write()`，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态 ， 其次，还**发生了 4 次数据拷贝**，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的 

1.  *第一次拷贝*，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的 
2.  *第二次拷贝*，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的 
3.  *第三次拷贝*，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的 
4.  *第四次拷贝*，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的 
5. 原因： 读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数 ，

####  实现方式

#####  mmap + write

`mmap()` 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作

1.  应用进程调用了 `mmap()` 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区 

2.  应用进程再调用 `write()`，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据 

3.  最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的 

4.   通过使用 `mmap()` 来代替 `read()`， 可以减少一次数据拷贝的过程 ，但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次 

   ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHKiczImueTBjnrXSnRM13mokPruysrVuhMBbPeLsoFylbxLo07NGXLqyzKZfHI3r29kdqkDaImsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

##### sendfile

 首先，它可以替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销 ， 其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝 

![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHKiczImueTBjnrXSnRM13mD19b7SCEuj1icTmFg5kg4xmIq0vqhqKVM1o7oISMaZxoUcKCl7yGwvg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###### SG-DMA

 如果网卡支持 SG-DMA（*The Scatter-Gather Direct Memory Access*）技术，`sendfile()` 系统调用的过程发生了点变化 

1.  第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里 

2.  第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中 

   ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcHKiczImueTBjnrXSnRM13m9aUVVJ2BT9QBoPQqB1iaTSn4kSL1sR9sQYLGbsPxticvZgIptotGT3Ng/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  这就是所谓的**零拷贝（\*Zero-copy\*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的** ， 零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运** 

#### PageCache 作用

1. 内核缓冲区实际上是**磁盘高速缓存（PageCache）**， 程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 **PageCache 来缓存最近被访问的数据**，当空间不足时淘汰最久未被访问的缓存 
2.  对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，**PageCache 使用了「预读功能」** 

##### 传输大文件

1.  PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了 
2.  PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次 
3.  **在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O（ 不是缓存IO,绕开 PageCache ）」来替代零拷贝技术** 

### io模型

####  同步阻塞

 应用程序发起了一个IO请求（以读取数据为例），此时需要进行一次系统调用，内核由用户态切换到内核态，内核开始跟硬件设备进行交互并从硬件设备中读取数据，此时可能硬件设备还没有接收到数据，所以内核函数一直阻塞，直到数据到达才进行返回 

#### 同步非阻塞

 应用程序发起了一次读取数据的请求，还是会发起系统调用，但是此时内核根据硬件中是否有数据执行不同的操作，如果有数据，那么将数据拷贝到用户空间，如果没有数据也会返回一个标志，比如-1，应用程序在轮询期间并没有一直阻塞，而是可以继续执行

#### 异步非阻塞

 应用程序只需要发起一次读取数据的请求，接下来就等着内核将数据拷贝到用户空间，并且内核将数据拷贝完成后会通知应用程序，在整个过程中程序可以继续往下执行  

####  描述 

1.  阻塞/非阻塞：描述的是调用者调用方法后的状态 
2. 同步/异步：描述的方法跟调用者间通信的方式，如果不需要调用者主动等待，调用者调用后立即返回，然后方法本身通过回调，消息通知等方式通知调用者结果，就是异步的。如果调用方法后一直需要调用者一直等待方法返回结果，那么就是同步的

