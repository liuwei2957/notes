### 订单

#### 表

1. 订单主表：也叫订单表，保存订单的基本信息。

2. 订单商品表：保存订单中的商品信息。

3. 订单支付表：保存订单的支付和退款信息。

4. 订单优惠表：保存订单使用的所有优惠信息

#### 幂等

1. 对于创建订单服务来说，可以通过预先生成订单号，然后利用数据库中订单号的唯一约束这个特性，避免重复写入订单，实现创建订单服务的幂等性。对于更新订单服务，可以通过一个版本号机制，每次更新数据前校验版本号，更新数据同时自增版本号，这样的方式，来解决 ABA 问题，确保更新订单服务的幂等性
2. 每次请求之前必须先生成一个唯一的请求id,服务端将该id暂时放入redis。客户端请求时必须携带上这个id，借口会首先到redis中查询，如何有的话就继续后续的处理逻辑，同时删除该id,灭有的话就退出，返回不能重复请求的错误到客户端

### 商品

#### 表结构

1. 基本信息，使用mysql，它包括商品的主副标题、价格、颜色等一些商品最基本、主要的属性。这些属性都是固定的，不太可能会因为需求或者不同的商品而变化，而且，这部分数据也不会太大，一定要记得保留商品数据的每一个历史版本。因为商品数据是随时变化的，但是订单中关联的商品数据，必须是下单那个时刻的商品数据
2. 商品参数，使用mongodb，参数就是商品的特征，不同类型的商品，它的参数是完全不一样的，既然一个表不能解决问题，如果品类比较少，可以为每个类别分别建一张表，多的话使用mongodb，适合属性不固定的数据
3. 图片视频，图片和视频由于占用存储空间比较大，一般的存储方式都是，在数据库中只保存图片视频的 ID 或者 URL，实际的图片视频以文件的方式单独存储，首选的方式就是保存在对象存储，对象存储可以简单理解为一个无限容量的大文件 KV 存储，它的存储单位是对象，其实就是文件，可以是一张图片，一个视频，也可以是其他任何文件。每个对象都有一个唯一的 key，利用这个 key 就可以随时访问对应的对象
4. 商品介绍，包含了大量的带格式文字、图片和视频。其中图片和视频自然要存放在对象存储里面，商品介绍的文本，一般都是随着商详页一起静态化，保存在 HTML 文件中

### 购物车

#### 表结构

1. 用户id，商品id，商品数量，加购时间，勾选状态，也可以采用redis，购物车数据可靠性要求不高

### 账户

账户系统负责记录和管理用户账户的余额，这个余额就是每个用户临时存在电商的钱，来源可能是用户充值或者退货退款等多种途径

#### 表结构

1. 账户余额，用户id，账户余额，更新时间
2. 流水，流水ID、交易金额、交易时间戳以及交易双方的系统、账户、交易单号等信息，流水记录只能新增，一旦记录成功不允许修改和删除，即使是由于正当原因需要取消一笔已经完成的交易，也不应该去删除交易流水。正确的做法是再记录一笔“取消交易”的流水，流水号必须是递增的，我们需要用流水号来确定交易的先后顺序

### 分布式事务

#### 2PC

1. 2PC 也叫二阶段提交，所谓的二阶段指的是准备阶段和提交阶段，所谓的二阶段指的是准备阶段和提交阶段，准备阶段失败需要回滚，提交阶段失败，需要不断重试，适用于需要强一致，并且并发量不大的场景
2. 本地消息表，记录“操作日志”，其他系统异步读取，如果失败可以不断重试，数据最终一致性

### 商品搜索

1. ES 本质上是一个支持全文搜索的分布式内存数据库，特别适合用于构建搜索系统。ES 之所以能有非常好的全文搜索性能，最重要的原因就是采用了倒排索引。倒排索引是一种特别为搜索而设计的索引结构，倒排索引先对需要索引的字段进行分词，然后以分词为索引组成一个查找树，这样就把一个全文匹配的查找转换成了对树的查找，这是倒排索引能够快速进行搜索的根本原因
2. 用户输入搜索推荐，es针对这种情况提供了suggestion api，并提供的专门的数据结构应对搜索推荐，性能高于match，但它应用起来也有局限性，就是只能做前缀匹配

### 复制状态机

1. 存储系统中的数据称为状态（也就是 MySQL 中的数据），状态的全量备份称为快照（Snapshot），就像给数据拍个照片一样。我们按照顺序记录更新存储系统的每条操作命令，就是操作日志（Commit Log，也就是 MySQL 中的 Binlog）
2. 复制数据的时候，只要基于一个快照，按照顺序执行快照之后的所有操作日志，就可以得到一个完全一样的状态。在从节点持续地从主节点上复制操作日志并执行，就可以让从节点上的状态数据和主节点保持同步
3. 主从同步做数据复制时，一般可以采用几种复制策略。性能最好的方法是异步复制，主节点上先记录操作日志，再更新状态数据，然后异步把操作日志复制到所有从节点上，并在从节点执行操作日志，得到和主节点相同的状态数据
4. 异步复制的劣势是，可能存在主从延迟，如果主节点宕机，可能会丢数据。另外一种常用的策略是半同步复制，主节点等待操作日志最少成功复制到 N 个从节点上之后，再更新状态，这种方式在性能、高可用和数据可靠性几个方面都比较平衡，很多分布式存储系统默认采用的都是这种方式

### 海量数据查询

1. 解决海量数据导致存储系统慢的问题，思想非常简单，就是一个“拆”字，把一大坨数据拆分成 N 个小坨，学名叫“分片（Shard）”，拆开之后，每个分片里的数据就没那么多了，然后让查找尽量落在某一个分片上，这样来提升查找性能
2. 存档历史数据提升查询性能，当单表的订单数据太多，多到影响性能的时候，首选的方案是，归档历史数据，所谓归档，其实也是一种拆分数据的策略。简单地说，就是把大量的历史订单移到另外一张历史订单表中，因为像订单这类具有时间属性的数据，都存在热尾效应。大多数情况下访问的都是最近的数据，但订单表里面大量的数据都是不怎么常用的老数据
3. 大批量删除数据，可以根据id排序，因为按 ID 排序后，我们每批删除的记录，基本都是 ID 连续的一批记录，由于 B+ 树的有序性，这些 ID 相近的记录，在磁盘的物理文件上，大致也是放在一起的，这样删除效率会比较高，也便于 MySQL 回收页

### 分库分表

#### 原因

1. 是数据量太大查询慢的问题。这里面讲的“查询”其实主要是事务中的查询和更新操作，因为只读的查询可以通过缓存和主从分离来解决，解决查询慢，只要减少每次查询的数据总量就可以了，也就是说，分表就可以解决问题
2. 是为了应对高并发的问题，一个数据库实例撑不住，就把并发请求分散到多个实例中去，所以，解决高并发的问题是需要分库的
3. 分多少个库需要用并发量来预估，分多少表需要用数据量来预估
4. 选择 Sharding Key 的时候，一定要能兼容业务最常用的查询条件，让查询尽量落在一个分片中，分片之后无法兼容的查询，可以把数据同步到其他存储中去

#### sharding key选择

1. key后面拼上其他维度
2. 用其他维度再分库分表
3. 同步到其他存储系统
4. 建索引表

#### 分片算法

1. 时间范围

2. 哈希，一致性哈希

3. 查表法，分片映射表（缺点是需要二次查询，实现起来更复杂，性能上也稍微慢一些。但是，分片映射表可以通过缓存来加速查询）

4. 范围分片容易产生热点问题，但对查询更友好，适合适合并发量不大的场景；哈希分片比较容易把数据和查询均匀地分布到所有分片中；查表法更灵活，但性能稍差

5. 对于订单表进行分库分表，一般按照用户 ID 作为 Sharding Key，采用哈希分片算法来均匀分布用户订单数据。为了能支持按订单号查询的需求，需要把用户 ID 的后几位放到订单号中去

### redis集群

1. 小规模的集群建议使用官方的 Redis Cluster，在节点数量不多的情况下，各方面表现都不错，gossip协议在集群规模太大的情况下，数据不同步的问题会被明显放大，还有一定的不确定性，如果出现问题很难排查
2. 再大一些规模的集群，可以考虑使用 twemproxy 或者 Codis 这类的基于代理的集群架构，（代理作用：1.负责在客户端和 Redis 节点之间转发请求和响应。客户端只和代理服务打交道，代理收到客户端的请求之后，再转发到对应的 Redis 节点上，节点返回的响应再经由代理转发返回给客户端，2.负责监控集群中所有 Redis 节点状态，如果发现有问题节点，及时进行主从切换，3.是维护集群的元数据，这个元数据主要就是集群所有节点的主从信息，以及槽和节点关系映射表）增加了一层代理转发，每次数据访问的链路更长了，必然会带来一定的性能损失。而且，代理服务本身又是集群的一个单点
3. 相比于代理方案，使用定制客户端的方案性能更好，很多大厂采用的都是类似的架构，把代理服务的寻址功能前移到客户端中去。客户端在发起请求之前，先去查询元数据，就可以知道要访问的是哪个分片和哪个节点，然后直连对应的 Redis 节点访问数据，客户端不用每次都去查询元数据，因为这个元数据是不怎么变化的，客户端可以自己缓存元数据，如果某个分片的主节点宕机了，新的主节点被选举出来之后，更新元数据里面的信息，这个元数据服务仍然是一个单点，但是它的数据量不大，访问量也不大，相对就比较容易实现。我们可以用 ZooKeeper、etcd 甚至 MySQL 都能满足要求

### redis同步mysql

1. 对于缓存数据更新的方法，可以订阅数据更新的 MQ 消息来异步更新缓存，更通用的方法是，把缓存更新服务伪装成一个 MySQL 的从节点，订阅 MySQL 的 Binlog，通过 Binlog来更新 Redis 缓存

