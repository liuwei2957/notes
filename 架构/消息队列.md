### 消息队列模型

1. 发布订阅（广播）：使用topic作为通信载体
2. p2p点多点：使用queue作为通信载体

### 消息队列构成

1. Broker:消息服务器，作为Server提供消息核心服务
2. Producer:消息生产者，业务的发起方，负载生产消息传输给broker
3. Consumer:消息消费者，业务的处理方，负载从broker获取消息并进行业务逻辑处理
4. Topic:主题：发布订阅模式下的消息统一汇集地，不同生产者向Topic发送消息，由不同的mq服务器分发到不同的订阅者，实现消息的广播
5. Queue:队列，p2p模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
6. Message:消息体，根据不同通信协议定义固定格式进行编码的数据包，来封装业务数据，实现消息的传输

### 消息队列协议

1. AMQP协议：应用层协议的一个开放标准，为面向消息中间件设计
2. MQTT协议：格式简洁，占用带宽小，移动端通信，push，嵌入式系统，基于tcp的二进制协议
3. STOMP协议：简单文本消息协议
4. XMPP协议：基于xml的协议
5. 自定义协议：redis/kafka/rocketmq自定义二进制协议，基于tcp/ip socket接口进行传输

### 生产环境推荐

1. kafka，高吞吐，高可靠性可容忍场景：日志处理
2. rocketmq，高可靠场景，电商订单消息

### rocketmq

#### 存储模型

1. 顺序写，随机读
2. 所有数据单独存储在一个commit log,完全顺序写，随机读
3. 对最终用户展现的队列实际只存储消息在commit log的位置信息，并且串行方式刷盘
4. 好处：队列轻量化，单个队列数据量非常少，对磁盘的访问串行化，避免磁盘竞争
5. 缺点：读一条消息，先读consume queue，再读commit log,增加了读开销，要保证commit log与consume queue完全一致，增加了架构复杂性（mmap机制实现）

#### 刷盘策略

1. 异步：写完pageCache直接返回，可配置
2. 同步：写入pageCache，线程等待，通知刷盘线程刷盘，刷盘线程刷盘后，唤醒前端等待线程，可能是一批线程，前端等待线程向用户返回成功

#### 高可用

##### 非时序消息

###### 1. 多个master-slave对

2. pub多个master（topic相同）
3. sub多个master

##### 严格时序消息

1. 单机单线程，master-slave
2. 如果master挂了，会发送失败，同时也不能消费

#### 消息可靠性

1. ack：producer重试3次，consumer失败，可以异步再消费，可以回溯，消费offset可以保存本地，或者保存到broker
2. 网络：netty

