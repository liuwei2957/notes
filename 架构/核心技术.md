### 高可用设计

#### 什么是高可用

7x24，任何人，任何时间，任何地点，任何服务，都能得到想要的结果

#### 为什么需要高可用

1. 硬件：生命周期，硬件故障，网络划分（CA不存在，没有网络划分，是单机）
2. 软件：bug，性能极限，软件间相互影响

#### 评估方式

1. n个9
2. 停机时间影响请求量/总的请求量

#### 设计手段

1. 服务冗余，无状态化：快速扩容，弹性缩容
2. 负载均衡，幂等设计：
3. 超时机制
4. 异步化设计，非核心流量异步化，减少主流程
5. 服务限流降级熔断
6. 数据复制/缓存/sharding
7. 架构拆分，服务治理
8. 服务实时监控
9. 服务分级，不同级别服务故障影响程度不一样

#### 如何无缝停止线上服务

1. 网关层已具备热切换能力，热开关切换，网关拒绝所有还没到业务逻辑层的请求，进入业务层逻辑层的请求继续处理，可以通过日志查看所有请求是否处理完毕，然后停机，前端也可以用超时时间来控制，过超时时间后停止网关（先关网关，网关里的io线程把请求入队，worker线程从队列获取请求处理之前判断热开关是否开启）
2. 网关层不已具备热切换能力，iptables防火墙限制请求只出不进



### 高并发设计

#### 系统性能

1. 吞吐量
2. 响应延迟

#### 性能优化目标

1. 缩短响应时间
2. 提高并发数（增加吞吐量）
3. 让系统处于合理状态（机器资源利用率，响应延迟，吞吐量）

#### 优化手段

1. 空间换时间：系统时间是瓶颈，如缓存复用计算结果，降低时间开销，因为CPU时间较内存容量更加昂贵
2. 时间换空间：数据大小是瓶颈，如网络传输是瓶颈，使用系统时间换取传输的空间，使用HTTP的gzip压缩算法，app的请求分类接口，使用版本号判断哪些数据更新，只下周更新的数据
3. 找到系统瓶颈：分析系统业务流程，找到关键路径并分解优化（调用了多少RPC接口，载入多少数据，使用什么算法，非核心流程能否异步化，没有数据依赖的逻辑能否并行执行）

#### 优化层次

1. 架构设计层次：关注系统控制，数据流程，拆分系统微服务化，使各部分系统整体负载更加均衡，充分发挥硬件设施性能优势
2. 算法逻辑层次：算法选择是否高效，算法逻辑优化，优化任务并行处理，使用无锁数据结构，空间换时间（ThreadLocal），时间换空间（采用压缩算法压缩数据，更复杂的逻辑减少数据传输）
3. 代码优化层次：代码实现是否合理，是否创建了过多的对象，循环遍历是否高效,cache使用的是否合理，是否重用计算结果

#### 秒杀系统架构

1. 数据分层次校验，上层尽量把无效请求过滤掉，上层可以是不精确的过滤
2. 层层限流，最后一层做数据一致性校验，扣减库存
3. html,js,css等静态文件存放cdn,缓存到用户端（app/浏览器）
4. 非实时动态数据缓存在用户访问链路中靠近用户的位置，粗过滤一部分流量，比如用户是否有秒杀资格，秒杀是否已结束等
5. 实时数据如用户营销数据（红包，折扣），商品库存等再过滤一批用户
6. 经过多层过滤最终落到数据库的流量已经很少，最终在数据库层面使用事务保证扣减库存的准确性

### 无状态化设计

冗余部署的多个进程任何时候都完全对等，请求提交到冗余部署的任一模块，处理结果完全一样，模块不存储业务的上下文信息，仅根据每次请求携带的数据进行处理

#### 用户session设计

1. 直接存放在网关层：单点，网关层有状态
2. 存在外部存储（redis集群）：一致性hash会存在网络瞬断，导致节点漂移问题
3. session存在客户端，客户端每次请求携带session（session丢失问题，消耗流量）

### 负载均衡设计

1. 硬件：F5，A10，Radware
2. 软件：LVS（4层），Nginx（7层），HAProxy（4或7层）

#### 算法

1. Random随机：按权重设置随机概率
2. RoundRobin轮询：按约定后的权重设置轮询
3. 一致性Hash：相同参数的请求总是发到同一提供者

#### 广义负载均衡

1. 完整的故障处理恢复机制，故障自动发现（zk配置中心watcher集中实现）
2. 故障服务自动摘除，服务熔断机制（服务假死，心跳还在，zk不能处理这种故障，只能在网关里做，网关把业务逻辑层返回的请求响应存到一个内存队列里，统计错误比率，然后杀掉网关和业务逻辑层的长连接，重启服务之前需要，jstack两次（保存上下文），kill进程，sleep 6s（如果重启时间小于zk两次心跳时间，zk不知道client挂了），重启进程）
3. 请求自动重试
4. 服务恢复自动发现

### 服务幂等设计

