### 高可用设计

#### 什么是高可用

7x24，任何人，任何时间，任何地点，任何服务，都能得到想要的结果

#### 为什么需要高可用

1. 硬件：生命周期，硬件故障，网络划分（CA不存在，没有网络划分，是单机）
2. 软件：bug，性能极限，软件间相互影响

#### 评估方式

1. n个9
2. 停机时间影响请求量/总的请求量

#### 设计手段

1. 服务冗余，无状态化：快速扩容，弹性缩容
2. 负载均衡，幂等设计：
3. 超时机制
4. 异步化设计，非核心流量异步化，减少主流程
5. 服务限流降级熔断
6. 数据复制/缓存/sharding
7. 架构拆分，服务治理
8. 服务实时监控
9. 服务分级，不同级别服务故障影响程度不一样

#### 如何无缝停止线上服务

1. 网关层已具备热切换能力，热开关切换，网关拒绝所有还没到业务逻辑层的请求，进入业务层逻辑层的请求继续处理，可以通过日志查看所有请求是否处理完毕，然后停机，前端也可以用超时时间来控制，过超时时间后停止网关（先关网关，网关里的io线程把请求入队，worker线程从队列获取请求处理之前判断热开关是否开启）
2. 网关层不已具备热切换能力，iptables防火墙限制请求只出不进



### 高并发设计

#### 系统性能

1. 吞吐量
2. 响应延迟

#### 性能优化目标

1. 缩短响应时间
2. 提高并发数（增加吞吐量）
3. 让系统处于合理状态（机器资源利用率，响应延迟，吞吐量）

#### 优化手段

1. 空间换时间：系统时间是瓶颈，如缓存复用计算结果，降低时间开销，因为CPU时间较内存容量更加昂贵
2. 时间换空间：数据大小是瓶颈，如网络传输是瓶颈，使用系统时间换取传输的空间，使用HTTP的gzip压缩算法，app的请求分类接口，使用版本号判断哪些数据更新，只下周更新的数据
3. 找到系统瓶颈：分析系统业务流程，找到关键路径并分解优化（调用了多少RPC接口，载入多少数据，使用什么算法，非核心流程能否异步化，没有数据依赖的逻辑能否并行执行）

#### 优化层次

1. 架构设计层次：关注系统控制，数据流程，拆分系统微服务化，使各部分系统整体负载更加均衡，充分发挥硬件设施性能优势
2. 算法逻辑层次：算法选择是否高效，算法逻辑优化，优化任务并行处理，使用无锁数据结构，空间换时间（ThreadLocal），时间换空间（采用压缩算法压缩数据，更复杂的逻辑减少数据传输）
3. 代码优化层次：代码实现是否合理，是否创建了过多的对象，循环遍历是否高效,cache使用的是否合理，是否重用计算结果

#### 秒杀系统架构

1. 数据分层次校验，上层尽量把无效请求过滤掉，上层可以是不精确的过滤
2. 层层限流，最后一层做数据一致性校验，扣减库存
3. html,js,css等静态文件存放cdn,缓存到用户端（app/浏览器）
4. 非实时动态数据缓存在用户访问链路中靠近用户的位置，粗过滤一部分流量，比如用户是否有秒杀资格，秒杀是否已结束等
5. 实时数据如用户营销数据（红包，折扣），商品库存等再过滤一批用户
6. 经过多层过滤最终落到数据库的流量已经很少，最终在数据库层面使用事务保证扣减库存的准确性

### 无状态化设计

冗余部署的多个进程任何时候都完全对等，请求提交到冗余部署的任一模块，处理结果完全一样，模块不存储业务的上下文信息，仅根据每次请求携带的数据进行处理

#### 用户session设计

1. 直接存放在网关层：单点，网关层有状态
2. 存在外部存储（redis集群）：一致性hash会存在网络瞬断，导致节点漂移问题
3. session存在客户端，客户端每次请求携带session（session丢失问题，消耗流量）

### 负载均衡设计

1. 硬件：F5，A10，Radware
2. 软件：LVS（4层），Nginx（7层），HAProxy（4或7层）

#### 算法

1. Random随机：按权重设置随机概率
2. RoundRobin轮询：按约定后的权重设置轮询
3. 一致性Hash：相同参数的请求总是发到同一提供者

#### 广义负载均衡

1. 完整的故障处理恢复机制，故障自动发现（zk配置中心watcher集中实现）
2. 故障服务自动摘除，服务熔断机制（服务假死，心跳还在，zk不能处理这种故障，只能在网关里做，网关把业务逻辑层返回的请求响应存到一个内存队列里，统计错误比率，然后杀掉网关和业务逻辑层的长连接，重启服务之前需要，jstack两次（保存上下文），kill进程，sleep 6s（如果重启时间小于zk两次心跳时间，zk不知道client挂了），重启进程）
3. 请求自动重试
4. 服务恢复自动发现

### 服务幂等设计

1. 请求层面：保证请求重复执行和执行一次结果相同
2. 业务层面：同一用户不重复下单，商品不超买，MQ消费端去重
3. 读/写请求层面：写请求有可能
4. 架构层面：数据访问层（insert时不用自增主键，用业务主键，update时使用绝对值），分布式事务
5. 冗余部署多个线程：并发转变成串行消费（分布式锁+业务状态判断）

### 分布式锁

分布式环境下，锁定全局唯一资源，请求处理串行化，实际表现为互斥锁

#### 目的

1. 交易订单锁定：防止重复下单，解决业务层面幂等性问题
2. MQ消息消费幂等性：发送消息重复，消息消费端去重
3. 在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行改价操作，状态的修改行为需要做串行处理，避免出现数据错乱

#### 基于redis分布式锁方案

唯一线程串行处理

1. setnx命令在指定的key不存在时，为key设置值，设置成功返回1，失败返回0（存在问题：锁时间不可控，无法续租，单点问题，主从方式，主从数据异步，会存在锁失效问题）
2. 官方建议：使用redlock算法保证，但是至少需要3个redis主从实例来完成，维护成本较高，redlock等同于自己实现简单的一致性协议，容易出错
3. 问题本质：分布式锁是CP模型，redis集群是AP模型

#### 设计目标

1. 强一致性
2. 服务高可用，系统稳健
3. 锁自动续约及其自动释放
4. 代码高度抽象业务接入简单
5. 可视化管理后台，监控及管理

#### etcd分布式锁实现

1. client ttl模式
2. clientA拿锁成功，clientB拿锁失败
3. A服务需要对etcd保持后台心跳线程，每次心跳重置锁的过期时间，负载锁的续租
4. 锁的清理：如果调用方正常结束，通过cas接口调用delete方法自动清理etcd中的key值，如果调用方异常终止，心跳就不存在了，等待原有锁ttl过期后，锁资源释放
5. etcd v3版本api天然提供分布式锁功能，只需申请锁，释放锁，不用关注锁的续租问题

### 分布式事务

数据分散在多处，多个db，db和缓存

#### 分类

1. 刚性事务：强一致性，xa模型，cp模型，满足传统事务的acid特性
2. 柔性事务：最终一致性，base理论，ap模型

#### xa模型

1. xa规范由ap,rm,tm组成
2. ap指应用程序，定义事务边界，并访问事务边界内的资源
3. rm指管理计算机共享的资源，即数据库
4. tm指事务管理器，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交，回滚

5. 实现方式：2pc（两阶段提交）
6. 过程：tm发起prepare投票，rm都同意后，tm再发起commit，commit过程出现宕机等异常，节点服务重启后根据xa recover再次进行commit补偿
7. 缺点：同步阻塞模型，数据库锁定时间长，全局锁，并发低，不适合长事务场景

#### 柔性事务

是对xa协议的妥协，它通过降低强一致性要求，从而降低数据库锁定时间，提升可用性，典型实现：

1. tcc模型：try-confirm-cancel，tcc模型完全交由业务实现，每个子业务都需要实现try-confirm-cancel接口，对业务侵入大，资源锁定交由业务方，try:尝试执行业务，完成所有业务检查，预留必要的业务资源，confirm:真正执行业务，不再做业务检查，cancel:释放整个try阶段预留的业务资源
2. saga模型：把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块，当saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性，业务层加锁控制并发

### 异步场景分布式事务设计

1. 业务方提供本地操作成功回查接口，事务消息：mq提供分布式事务功能，达到最终一致性，半消息：暂不能投递的消息，发送方已经将消息成功发送到了mq服务端，但是服务端未收到生产者对该消息的二次确认，此时消息被标记为不能投递状态，消息回查：由于网络闪断，生产者应用重启等原因，导致某条事务消息的二次确认丢失，mq服务端提供扫描发现某条消息长期处于半消息时，需要主动向生产者询问该消息的最终状态（commit或者rollback）