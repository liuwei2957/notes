### mysql服务器逻辑架构

1. 最上层是连接处理，授权认证，安全等
2. 第二层是查询解析，分析，优化，缓存，所有跨存储引擎的功能都在这一层实现：存储过程，触发器，视图
3. 存储引擎，和linux下的各种文件系统一样，服务器通过api与存储引擎进行通信，这些接口屏蔽了不同存储引擎之间的差异。存储引擎api包含几十个底层函数，用于执行诸如，开始一个事务，根据主键提取一行记录等操作，存储引擎不会去解析sql(Innodb会解析外键定义，因为mysql服务器本身没有实现该功能)

### 锁粒度

#### 表锁

是开销最小的锁策略，它会锁定整张表，在特定的场景中，表锁也可能有良好的性能，例如READ LOCAL表锁支持某些类型的并发写操作，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面，反之读锁则不能插入到写锁的前面

#### 行锁

可以最大程度地支持并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎实现，而mysql服务器层没有实现

### 事务的ACID特性

#### 原子性

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚

#### 一致性

数据库总是从一个一致性的状态转移到另外一个一致性的状态，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中

#### 隔离性

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的

#### 持久性

一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失(不可能有能做到100%的持久性保证策略)

### 隔离级别

#### READ UNCOMMITTED(读未提交)

事务中的修改，即使没有提交，对其他事务也是可见的，会出现脏读，从性能上来说，READ UNCOMMITTED不会比其他级别高很多

#### READ COMMITTED(读已提交)

READ COMMITTED能满足隔离性的简单定义，一个事务开始时，只能看见已经提交的事务所做的修改，也叫不可重复读，因为两次执行同样的查询，可能会得到不一样的结果

#### REPEATABLE READ(可重复读)

该级别保证了在同一个事务中多次读取同样记录的结果是一致的，但是理论上，可重复读隔离级别无法解决幻读的问题，幻读指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读，Innodb通过MVCC解决了幻读的问题

### SERIALIZABLE(串行化)

是最高的隔离级别，它通过强制事务串行执行，避免了幻读问题，SERIALIZABLE会在读取的每一行数据上加锁

### 死锁

指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象，当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁，多个事务同时锁定一个资源时，也会产生死锁

#### 解决办法

1. 检测到死锁的循环依赖，立即返回一个错误
2. 当查询的时间达到锁等待超时的设定后放弃锁请求
3. Innodb是将持有最少行级排他锁的事务进行回滚

### 事务日志

事务日志可以帮助提高事务的效率，使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录持久到硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘，事务日志采用的是追加的方式，，因此写日志的操作是磁盘上一小块区域的顺序io，事务日志持久化后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，通常称为预写日志，修改数据需要写两次磁盘，如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据

### 两阶段锁定协议

在事务执行过程中，随时都可以执行锁定，但锁只有在执行commit或者rollback时才会释放，并且所有的锁是在同一时刻被释放

### MVCC

MVCC的实现，是通过保存数据在某个时间点的快照来实现的，不管需要执行多长时间，每个事务看到的数据都是一致的，根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的，MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作

#### Inonodb的实现

Innodb的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，一个保存了行的创建版本号，一个保存行的删除版本号，每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的版本号会作为事务的版本号，insert：innodb为新插入的每一行保存当前系统版本号作为行版本号，delete：innodb为删除的每一行保存当前系统版本号作为行删除标识，update：innodb为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识

#### RR级别MVCC

Innodb会根据以下两个条件检查每行记录

1. Innodb只查找版本早于当前事务版本的数据行(也就是说，行的系统版本号小于等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的
2. 行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除