### 合理利用 CPU 的高性能

1. CPU 增加了缓存，以均衡与内存的速度差异
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用

### 并发程序问题根源

1. 缓存导致的可见性问题，一个线程对共享变量的修改，另外一个线程能够立刻看到，称为可见性
2. 线程切换带来的原子性问题，在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了，这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了，操作系统做任务切换，可以发生在任何一条CPU 指令执行完，而不是高级语言里的一条语句，我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性，CPU能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符
3. 编译优化带来的有序性问题，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序(new 操作符执行步骤：分配一块内存 M，在内存 M 上初始化对象，然后 M 的地址赋值给引用变量)

### Happens-Before原则

前面一个的操作结果对后续操作是可见的

1.  程序的顺序性规则，指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作
2. volatile 变量规则，指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作
3. 传递性，如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C
4. 管程中锁的规则，指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁
5.  线程start() 规则，指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作
6. 线程join() 规则，指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作

### 原子性

一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“原子性”，原子性问题的源头是线程切换，而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换

#### 锁

我们把一段需要互斥执行的代码称为临界区

##### synchronized

1. 当修饰静态方法的时候，锁定的是当前类的 Class 对象
2. 当修饰非静态方法的时候，锁定的是当前实例对象 this

受保护资源和锁之间的关联关系是 N:1 的关系
