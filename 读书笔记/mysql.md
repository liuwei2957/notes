### mysql服务器逻辑架构

1. Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务 功能，以及所有的内置函数(如日期、时间、数学和加密函数等)，所有跨存储引擎的功能都在 这一层实现，比如存储过程、触发器、视图等
2. 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、 Memory等多个存储引擎，存储引擎api包含几十个底层函数，用于执行诸如，开始一个事务，根据主键提取一行记录等操作，存储引擎不会去解析sql(Innodb会解析外键定义，因为mysql服务器本身没有实现该功能)

### 查询sql执行顺序

1. 建立连接，建立连接的过程通常是比较复杂的，所以建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接，但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为 MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候 才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连 2. 如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证， 但是会将连接恢复到刚刚创建完时的状态）
2. 查询缓存，之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是 查询的结果（但是大多数情况下建议不要使用查询缓存，为什么呢?因为查询缓存往往弊大于利，查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库 来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。 比如，一个系统配置表，那这张表上的查询才适合使用查询缓存，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了）
3. 分析器，分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么，做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则， 判断你输入的这个SQL语句是否满足MySQL语法
4. 优化器，优化器是在表里面有多个索引的时候，决定使用哪个索引;或者在一个语句有多表关联(join)的时候，决定各个表的连接顺序
5. 执行器，开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有 权限的错误，如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口，第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，直到取到这个表的最后一行，执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端，你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的

### 更新sql

如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高，为此MySQL引入了WAL技术，WAL的全称是Write- Ahead Logging，它的关键点就是先写日志，再写磁盘，具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里 面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，write pos是当前记录的位置，一边写一边后移，checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件，有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个 能力称为crash-safe

#### binlog

redo log是 InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog(归档日志)，只依靠binlog是没有crash-safe能力的，InnoDB使用另外一套日志系统— — 也就是redo log来实现crash-safe能力

##### 不同点

1. redolog是InnoDB引擎特有的;binlog是MySQL的Server层实现的，所有引擎都可以使用
2. redolog是物理日志，记录的是“在某个数据页上做了什么修改”;binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”
3. redolog是循环写的，空间固定会用完;binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

#### 执行流程

1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一 行所在的数据页本来就在内存中，就直接返回给执行器;否则，需要先从磁盘读入内存，然 后再返回

2. 执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行 数据，再调用引擎接口写入这行新数据

3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redolog里面，此时redolog处 于prepare状态。然后告知执行器执行完成了，随时可以提交事务

4. 执行器生成这个操作的binlog，并把binlog写入磁盘

5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redolog改成提交(commit)状态，更新完成

   最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤:prepare和commit，这就是"两阶段提交"

##### 为什么必须有“两阶段提交”

这是为了让两份日志之间的逻辑一致

假设当前ID=2的行，字段c的值是0，要更新1

1. 先写redo log后写binlog。假设在redo log写完，binlog还没有写完的时候，MySQL进程异 常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回 来，所以恢复后这一行c的值是1。 但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份 日志的时候，存起来的binlog里面就没有这条语句。 然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这 个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同

2. 先写binlog后写redo log。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以 后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日 志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是 1，与原库的值不同

   可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的 状态不一致

#### redolog

1. redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候， 表示每次事务的redo log都直接持久化到磁盘。这个参数建议设置成1，这样可以保证 MySQL异常重启之后数据不丢失

### 锁粒度

#### 表锁

是开销最小的锁策略，它会锁定整张表，在特定的场景中，表锁也可能有良好的性能，例如READ LOCAL表锁支持某些类型的并发写操作，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面，反之读锁则不能插入到写锁的前面

#### 行锁

可以最大程度地支持并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎实现，而mysql服务器层没有实现

### 事务的ACID特性

#### 原子性

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚

#### 一致性

数据库总是从一个一致性的状态转移到另外一个一致性的状态，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中

#### 隔离性

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的

#### 持久性

一旦事务提交，则其所做的修改就会永久保存到数据库中，即使系统崩溃，修改的数据也不会丢失(不可能有能做到100%的持久性保证策略)

### 隔离级别

#### READ UNCOMMITTED(读未提交)

事务中的修改，即使没有提交，对其他事务也是可见的，会出现脏读，从性能上来说，READ UNCOMMITTED不会比其他级别高很多

#### READ COMMITTED(读已提交)

READ COMMITTED能满足隔离性的简单定义，一个事务开始时，只能看见已经提交的事务所做的修改，也叫不可重复读，因为两次执行同样的查询，可能会得到不一样的结果

#### REPEATABLE READ(可重复读)

该级别保证了在同一个事务中多次读取同样记录的结果是一致的，但是理论上，可重复读隔离级别无法解决幻读的问题，幻读指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻读，Innodb通过MVCC解决了幻读的问题

### SERIALIZABLE(串行化)

是最高的隔离级别，它通过强制事务串行执行，避免了幻读问题，SERIALIZABLE会在读取的每一行数据上加锁

### 死锁

指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象，当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁，多个事务同时锁定一个资源时，也会产生死锁

#### 解决办法

1. 检测到死锁的循环依赖，立即返回一个错误
2. 当查询的时间达到锁等待超时的设定后放弃锁请求
3. Innodb是将持有最少行级排他锁的事务进行回滚

### 事务日志

事务日志可以帮助提高事务的效率，使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录持久到硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘，事务日志采用的是追加的方式，，因此写日志的操作是磁盘上一小块区域的顺序io，事务日志持久化后，内存中被修改的数据在后台可以慢慢地刷回到磁盘，通常称为预写日志，修改数据需要写两次磁盘，如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据

### 两阶段锁定协议

在事务执行过程中，随时都可以执行锁定，但锁只有在执行commit或者rollback时才会释放，并且所有的锁是在同一时刻被释放

### MVCC

MVCC的实现，是通过保存数据在某个时间点的快照来实现的，不管需要执行多长时间，每个事务看到的数据都是一致的，根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的，MVCC只在READ COMMITTED和REPEATABLE READ两个隔离级别下工作

#### Inonodb的实现

Innodb的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，一个保存了行的创建版本号，一个保存行的删除版本号，每开始一个新的事务，系统版本号都会自动递增，事务开始时刻的版本号会作为事务的版本号，insert：innodb为新插入的每一行保存当前系统版本号作为行版本号，delete：innodb为删除的每一行保存当前系统版本号作为行删除标识，update：innodb为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识

#### RR级别MVCC

Innodb会根据以下两个条件检查每行记录

1. Innodb只查找版本早于当前事务版本的数据行(也就是说，行的系统版本号小于等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的
2. 行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行，在事务开始之前未被删除

